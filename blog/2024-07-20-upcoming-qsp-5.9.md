---
authors:
  - byte
  - fering
---

# Грядущая версия QSP 5.9

В новой версии кортежи:

* станут полноценным типом данных
* обретут свой собственный символ `%`
* возымеют вложенность, которой прежде не знали
* будут более круче деструктуризироваться
* начнут участвовать в различных бинарных операциях

## Полноценный тип данных

В прошлой версии Куспа кортежи оборачивались в строчный тип данных, что приводило к ряду сложностей и проблем. Теперь кортежи станут полноценным типом данных наряду с целочисленным типом и строчным и обретут свой собственный символ `%`.

Выглядеть это будет так (присваивание и использование):

```qsp
%персонаж = ($имя, $раса, уровень, %обмундирование, %спутник)
%обмундирование = ($оружие, $броня, %аксессуары)
%аксессуары = ($левыйАксессуар, $правыйАксессуар)
%спутник = ($спутникИмя, $спутникРаса, спутникУровень)
```

## Вложенность

Раньше были беды с вложенностью:

```php
# begin
  $firstTuple, $secondTuple = ((1, 2), (3, 4))
  $firstTuple &! ожидаешь (1, 2), но получаешь 1
  $secondTuple &! ожидаешь (3, 4), но получаешь вообще (2, 3, 4)
-
```

Теперь таких проблем нет

```php
# begin
  $эльф = ( _
    "Эльсинор", _
    "Эльф", _
    90, _
    ( _
      "Длинный лук", _
      "Эльфийская броня", _
      ("Кольцо мудрости", "Кольцо невидимости") _
    ), _
    ( _
      "Ария", _
      "Фея", _
      30 _
    ) _
  )
  @описание($эльф)
-

# описание
  $имя, $раса, уровень, $обмундирование = $args[0]
  $оружие, $броня, $аксессуары, $спутник = $обмундирование
  $левыйАксессуар, $правыйАксессуар = $аксессуары
  $спутникИмя, $спутникРаса, спутникУровень = $спутник
  'Имя: <<$имя>>'
  'Раса: <<$раса>>'
  'Уровень: <<уровень>>'
  'Обмундирование:'
  '  Оружие: <<$оружие>>'
  '  Броня: <<$броня>>'
  '  Аксессуары: <<$левыйАксессуар>>, <<$правыйАксессуар>>'
  'Спутник:'
  '  Имя: <<$спутникИмя>>'
  '  Раса: <<$спутникРаса>>'
  '  Уровень: <<спутникУровень>>'
-
```

Таким образом с кортежами невозможно было работать как с полноценным видом данных, еще вложенности у них никакой не было.

с ними можно было проводить все те же манипуляции, что и со строками.

***

из стринговых кортежей сделал полноценный `%` тип для кортежей, который решает проблему со вложенностью и операциями над ними

`len(%a)` будет возвращать количество элементов

## Деструктуризация

```php
num, %pair, $word = (1, (1, 2), "слово")
```

```php
%a, %b = ((1, 2), 4, 5)
%a & ! (1, 2)
%b & ! (4, 5)
```

```php
a, %b = (3, 5, 6, 7)
a & ! 3
%b & ! (5, 6, 7)
```

В общем, как в JS:

```js
const [x, ...xs] = [ 1, 2, 3 ]
console.log(x) // 1
console.log(xs) // [ 2, 3 ]
```

@varghexum, а можно ли как-то вытащить элементы из кортежа кроме деструктуризации? Я так понимаю, что вариант `%tuple[0]` нам не подходит, потому что вытаскивает первый элемент из массива кортежей

```
tupitem(%a,4)
```

## Операции на кортежами

Конкатенация кортежей:

```php
(3, 4) & 5 = (3, 4, 5)
5 & (3, 4) = (5, 3, 4)
(1, 5) & (3, 4) = (1, 5, 3, 4)
```

```
(3,2)+4 = (3+4,2+4)
(3,2)*4 = (3*4,2*4)
(3,2)-4 = (3-4,2-4)
(3,2)/4 = (3/4,2/4)

4+(3,4) = (4+3,4+4)
4-(3,4) = (4-3,4-4)
4*(3,4) = (4*3,4*4)
4/(3,4) = (4/3,4/4)

("ab", "cd") + "ff" =
= ("ab" + "ff", "cd" + "ff")

(2,3)+(5,6) = ??? как вариант (2+5,3+6)
(2,3)*(5,6) = ??? как вариант (2*5,3*6)
(аналогично для - и /)
```

Если `(x, y) + z = (x + z, y + z)`
тогда
```
(x, y) + (z, w) =
= (x + (z, w), y + (z, w)) =
= ((x + z, x + w), (y + z, y + w))
```
:sweat_smile:

сделал

(1, 2) * (3, 4, 5) =
= ((1 * (3, 4, 5), 2 * (3, 4, 5)) =
= ((1 * 3, 1 * 4, 1 * 5), (2 * 3, 2 * 4, 2 * 5))

иначе там сложности с размерностью
на самом деле не так важно, вряд ли кому-то в голову придёт перемножать/складывать/делить кортежи
а вот операции с одним значением могут быть удобны:

```bash
(3, 4, 5) * 7 = (3 * 7, 4 * 7, 5 * 7)
```
